---
layout: default
title: STS Walkthrough
subtitle: Step-by-step overview of STS's use-cases.
description: Walk through example usage of STS.
---

## Phase I: Bug Finding

we usually start by fuzzing to try to find bugs.

### Fuzzing Mode

Let's look in depth at a config file.

Now let's look in depth at fuzzer params.

Now let's look in depth at invariant checks.

BTW, you can drop into interactive mode by hitting ^C.

By default Fuzzer generates its inputs based on the probabilities defined in
config/fuzzer_params.py. That is, in a given round, the probability that an
event will be triggered is defined by the parameter specified in that file.

Fuzzer allows you to check invariants of your choice at specified intervals.

See the pydoc on Fuzzer.__init__ for more information about parameters.

### Interactive Mode

This mode provides a command line interface for users to interactively step
through the execution of the network. Type `help` for more information on the
command line interface.

If you have bug in mind, interactive mode is the perfect way to manually
trigger it.

Just change one thing in the config file.

## Phase II: Troubleshooting

Let's suppose we found a juicy bug. Luckily, our bug was .

### Replay Mode

All events observed in fuzzing and interactive mode are recorded for later replay.

Given an event trace generated by Interactive or Fuzzer, Replayer tries as best as it can to inject the inputs in
the trace in a way that reproduces the same result. It does this by listening
to the internal events in the trace and replaying inputs when it sees that the
causal dependencies have been met.

### MCS Finder Mode

Given an event trace, MCSFinder executes delta debugging to find the minimal
causal sequence. For each subsequence chosen by delta debugging, it
instantiates a new Replayer object to replay the execution, and checks at the
end whether the bug appears. To avoid garbage collection overhead, MCSFinder
runs each Replay in a separate process, and returns the results via XMLRPC.
See sts/util/rpc_forker.py for the mechanics of forking.

The runtime statistics of MCSFinder are stored in a dictionary and logged to a json file.

## Root Causing

### InteractiveReplayer Mode

Given an event trace (possibly minimized by MCSFinder), InteractiveReplayer
allows you to interactively step through the trace (a la OFRewind) in order to
understand the conditions that triggered a bug. This is helpful for:
  - visualizing the network topology
  - tracing the series of link/switch failures/recoveries
  - tracing the series of host migrations
  - tracing the series of flow_mods
  - tracing the series of traffic injections
  - perturbing the original event sequence by adding / removing inputs
    interactively
  - ...

### OpenFlowReplayer Mode

Delta debugging does not fully minimize traces (often for good reason,
e.g. delicate timings). In particular we have observed minimized traces often
contain many OpenFlow messages that time our or are overwritten, i.e. are not
directly relevent for triggering an invalid network configuratoon.

OpenFlowReplayer replays the OpenFlow messages from an event trace, enabling:
  - automatic filtering of flow_mods that timed out or were overwritten by
    later flow_mods.
  - automatic filtering of flow_mods that are irrelevant to a set of flow
    entries specified by the user.
  - interactive bisection of the OpenFlow trace to infer which messages were
    and were not relevent for triggering the bug (especially useful for tricky
    cases requiring human involvment). (TBD)

The tool can then spit back out a new event trace without the irrelevant
OpenFlow messages, to be replayed again by Replayer or InteractiveReplayer.

### Visualization tools

A common workflow:
  - Run `./simulator.py -c experiments/experiment_name/mcs_config.py`
  - Discover that the final MCS does not trigger the bug.
  - Open `visualize1D.html` in a web browser.
  - Load either the original (fuzzed) trace,
    `experiments/experiment_name/events.trace`,
    or the first replay of this trace,
    `experiments/experiment_name_mcs/interreplay_0_reproducibility/events.trace`,
    as the first timeline. I have found that it is often better to load the
    first replay rather than the original fuzzed trace, since this has
    timing information that matches the other replays much more closely.
  - Load the final replay of the MCS trace,
    `experiments/experiment_name_mcs/interreplay_._final_mcs_trace/events.trace`,
    as the second timeline.
  - Hover over events to further information about them, including functional equivalence
    with events in the other traces.
  - Load intermediate replay trace timelines if needed. Intermediate replay
    traces from delta debugging runs can be found in
    `experiments/experiment_name_mcs/interreplay_*`


### Pretty printing event traces.

The raw event.trace files are hard for humans to read.
./tools/pretty_print_event_trace.py.
