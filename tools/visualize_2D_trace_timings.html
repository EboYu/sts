<!doctype html>
<!--

This is a webpage for showing a Lamport time diagram of an event trace.
It's useful for visually spotting the root causes of
race conditions and other nasty bugs.

TODO(cs):
BUG: Uncaught TypeError: Cannot call method 'push' of undefined.
visualize_2D_trace_timings.html:165

-->
<html>
<head>
  <link rel="stylesheet" href="./d3-timeline/css/style.css">
  <!--<script src="http://code.jquery.com/jquery-latest.min.js"></script>-->
  <script src="./d3-timeline/lib/jquery-1.7.2.min.js"></script>
  <script src="./d3-timeline/lib/d3.v3.min.js"></script>
  <script src="./d3-timeline/src/d3-timeline.js"></script>
  <script src="./d3-timeline/lib/Tooltip.js"></script>
  <script src="./visualize_trace_timings_lib.js"></script>
  <script type="text/javascript">

    var primaryChartLoaded = false;
    var invariantViolations = {"InvariantViolation":true};
    var internalEvents = {"ControlMessageReceive":true,
                          "ControlMessageSend":true,
                          "ConnectToControllers":true,
                          "ControllerStateChange":true,
                          "DeterministicValue":true,
                          "DataplanePermit":true};

    // determines the number of toggle buttons at the top
    const numTimelines = 1;

    var timedelayms = 6; // chosen arbitrarily

    function formatData(data) {
      // Split by \n into raw json strings
      var split = data.split("\n");

      // find all controllers, switches, and hosts in data
      var entities = findEntities(split);

      for (i = 0; i < split.length-1; i++) {
        var str = split[i];
        var e = jQuery.parseJSON(str);
        var time_key = "time";
        if ("replay_time" in e) {
          time_key = "replay_time";
        }
        var epochMillis = (e[time_key][0] * 1000) + (e[time_key][1] / 1000);
        var point = {"starting_time": epochMillis,
                     "ending_time": epochMillis,
                     "label": e["label"],
                     "class": e["class"],
                     "sr_id": i};

        processEvent(e, point, entities);
      }

      return formatDataResult(entities);
    }

    function findEntities(data){
      var objEntities = {"controllers":{}, "switches":{}, "hosts":{}};

      for (i = 0; i < data.length-1; i++) {
        var str = data[i];
        var e = jQuery.parseJSON(str);

        if (e.class === "ControllerStateChange"){
          if ( !(e["controller_id"] in objEntities["controllers"]) ){
            objEntities["controllers"][e["controller_id"]] = [];
          }
        }
        else if (e.class === "ControlMessageSend" || e.class === "ControlMessageReceive"){
          if ( !(e["dpid"] in objEntities["switches"]) ){
            objEntities["switches"][e["dpid"]] = [];
          }
          if ( !(e["controller_id"] in objEntities["controllers"]) ){
            objEntities["controllers"][e["controller_id"]] = [];
          }
        }
        else if (e.class === "ControllerFailure" || e.class === "ControllerRecovery"){
          if ( !(e["fingerprint"][1] in objEntities["controllers"]) ){
            objEntities["controllers"][e["fingerprint"][1]] = [];
          }
        }
        else if (e.class === "TrafficInjection" || e.class === "HostMigration"){
          if ( !(e["host_id"] in objEntities["hosts"]) ){
            objEntities["hosts"][e["host_id"]] = [];
          }
        }        
        else if (e.class === "DataplaneDrop"){
          if ( !(e["fingerprint"][2] in objEntities["switches"]) ){
            objEntities["switches"][e["fingerprint"][2]] = [];
          }
        }

      }

      return objEntities;
    }

    function processEvent(e, point, entities, i){
      // Demultiplex by e["class"] for displaying events on corresponding entities
      var eventClass = e["class"];

        // display event on all controllers and switches
        if (eventClass === "ConnectToControllers") {
          for (var id in entities["controllers"]){
            addEvent("controllers", id, point, entities);
          }
          for (var id in entities["switches"]){
            addEvent("switches", id, point, entities);
          }
        }

        // display event on corresponding controller
        else if (eventClass === "ControllerStateChange"){
          addEvent("controllers", e["controller_id"], point, entities);
        }

        // display event on corresponding controller and switch
        else if (eventClass === "ControlMessageSend" || eventClass === "ControlMessageReceive"){
          // include a 6ms visual lag for messages to reach recipient
          epochMillisDelay = point["starting_time"] + (eventClass === "ControlMessageSend" ? timedelayms : -timedelayms);
          var pointDelay = {"starting_time": epochMillisDelay,
                            "ending_time": epochMillisDelay,
                            "label": e["label"],
                            "class": eventClass,
                            "sr_id": point["sr_id"]};

          addEvent("switches", e["dpid"], point, entities);
          addEvent("controllers", e["controller_id"], pointDelay, entities);
        }

        // display event on corresponding controller
        else if (eventClass === "ControllerFailure" || eventClass === "ControllerRecovery"){
          addEvent("controllers", e["controller_id"], point, entities);
        }

        // display event on corresponding switch
        else if (eventClass === "DataplaneDrop"){
          addEvent("switches", e["dpid"], point, entities);
        }

        // currently ignored
        else if (eventClass === "DataplanePermit"){

        }

        // display event on corresponding switch
        else if (eventClass === "ControlChannelBlock" || eventClass === "ControlChannelUnblock"){
          addEvent("switches", e["dpid"], point, entities);
        }

        // display event on corresponding switches
        else if ( eventClass === "LinkFailure" || eventClass === "LinkRecovery"){
          addEvent("switches", e["start_dpid"], point, entities);
          addEvent("switches", e["end_dpid"], point, entities);
        }

        // display event on corresponding switch
        else if ( eventClass == "SwitchFailure" || eventClass === "SwitchRecovery"){
          addEvent("switches", e["dpid"], point, entities);
        }

        // display event on corresponding host
        else if (eventClass === "TrafficInjection"){
          addEvent("hosts", e["host_id"], point, entities);
        }

        // display event on corresponding host and switches
        else if (eventClass === "HostMigration"){
          addEvent("hosts", e["host_id"], point, entities);
        }

    }

    // push event on to corresponding entity's timeline
    function addEvent(type, id, point, entities){
      entities[type][id].push(point);
    }

    // format results appropriately, in the order of controllers, switches, then hosts
    function formatDataResult(entities){
      var result = [];
      for (var ent in entities){
        // get a list of sorted keys such that order is preserved during the display
        var list = Object.keys(entities[ent]).sort(function(a,b){return a - b});
        for (i = 0; i < list.length; i++ ){
          var s = {};
          s["label"] = "" + ent + " " + list[i];
          s["times"] = entities[ent][list[i]];
          result.push(s);
        }
      }
      return result;
    }

  </script>
  <script type="text/javascript">

    function appendChart(data) {
      var timeline_type = "2d"
      var index = charts.length;
      var chartElement = "timeline" + index;
      var fileElement = ["fileinput" + index ];
      appendToDOM(fileElement, chartElement, timeline_type);
      pushChart(data, index, fileElement, chartElement, timeline_type);
    }

  </script>
</head>
<body>
</body>
</html>
