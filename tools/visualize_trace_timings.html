<!doctype html>
<html>
<head>
  <link rel="stylesheet" href="./d3-timeline/css/style.css">
  <!--<script src="http://code.jquery.com/jquery-latest.min.js"></script>-->
  <script src="./d3-timeline/lib/jquery-1.7.2.min.js"></script>
  <script src="./d3-timeline/lib/d3.v3.min.js"></script>
  <script src="./d3-timeline/src/d3-timeline.js"></script>
  <script src="./d3-timeline/lib/Tooltip.js"></script>
  <script type="text/javascript">
    // TODO(cs): add legend
    var primaryChartLoaded = false;
    var invariantViolations = {"InvariantViolation":true};
    var internalEvents = {"ControlMessageReceive":true,
                          "ControlMessageSend":true,
                          "ConnectToControllers":true,
                          "ControllerStateChange":true,
                          "DeterministicValue":true,
                          "DataplanePermit":true};

    // The key is the timeline index, and the value
    var data_timeline = {1:[], 2:[]};
    // timeline_num is a counter tracking what chart we are currently loading:
    // the first time we load this is set to 1, and incremented for
    // every subsequent load.
    var timeline_num = 0; // {1 or 2}

    function formatData(data) {
      timeline_num++;
      if (timeline_num > 2) {
        console.log("Warning: loaded more than twice. Returning");
        return
      }

      internal_times = {1:[], 2:[]};
      timed_out_times = {1:[], 2:[]};
      input_times = {1:[], 2:[]};
      // TODO(cs): assign the color red to violation_times
      violation_times = {1:[], 2:[]};
      new_event_times = {1:[], 2:[]};

      // Store arrays of raw json strings until both charts are loaded.
      data_timeline[timeline_num] = data.split("\n");

      if (timeline_num == 2) { // process after data for both timelines are entered
        processTimelineData(1, internal_times[1], timed_out_times[1], input_times[1], violation_times[1], new_event_times[1]);
        processTimelineData(2, internal_times[2], timed_out_times[2], input_times[2], violation_times[2], new_event_times[2]);
      }
      // if both charts haven't been loaded we just return empty data arrays,
      // which will be rendered harmlessly

      return [{"label": "internal", "times": internal_times[1]},
              {"label": "input", "times": input_times[1]},
              {"label": "timed_out", "times": timed_out_times[1]},
              {"label": "new_internal", "times": new_event_times[1]},
              {"label": "violation", "times": violation_times[1]},
              {"label": "", "times": []}, // blank line for spacing
              {"label": "internal", "times": internal_times[2]},
              {"label": "input", "times": input_times[2]},
              {"label": "timed_out", "times": timed_out_times[2]},
              {"label": "new_internal", "times": new_event_times[2]},
              {"label": "violation", "times": violation_times[2]}];
    }

    function initFileUpload(elementId, svg, chart, primaryChart) {
      var upload = document.getElementById(elementId);

      if (typeof window.FileReader === 'undefined') {
        alert("File API Not Supported");
      }

      upload.onchange = function (e) {
        e.preventDefault();

        var file = upload.files[0],
            reader = new FileReader();

        reader.onload = function (event) {
          var data = formatData(event.target.result);

          if (primaryChart) {
            primaryChartLoaded = true;
          }
          if (!primaryChart && primaryChartLoaded) {
            data = applyOffset(data);
          }

          timelineCircle(svg, chart, data);
        };
        reader.readAsText(file);

        return false;
      };
    }

    function processTimelineData(timelineNum, internalTimes, timedOutTimes, inputTimes, violationTimes, newEventTimes){
      var data = data_timeline[timelineNum];
      var start_position = 0;

      for (i = 0; i < data.length-1; i++) {
        var str = data[i];
        var e = jQuery.parseJSON(str);
        var epochMillis = (e["time"][0] * 1000) + (e["time"][1] / 1000);
        var e_id;

        if (timelineNum == 1) {
          // arbitrary id that is simply its position in the event list of timeline1
          e_id = i;
        } else {
          // id that corresponds to its functionally equivalent event in timeline1
          e_id = findFunctionallyEquivalentEventID(e, start_position);

          // update the starting position for the next event (to keep relative ordering correct)
          if (e_id != -1) {
            start_position = e_id+1;
          }
        }

        var point = {"starting_time": epochMillis,
                     "ending_time": epochMillis,
                     "label": e["label"],
                     "class": e["class"],
                     "fe_id": e_id};

        // Demultiplex by element["class"] for internal vs. input
        var eventClass = e["class"];
        if (eventClass === "InvariantViolation") {
          violationTimes.push(point);
        } else if (eventClass in internalEvents)  {
          if ("timed_out" in e && e["timed_out"]) {
            timedOutTimes.push(point);
          } else if ("new_internal_event" in e && e["new_internal_event"]) {
            newEventTimes.push(point);
          } else {
            internalTimes.push(point);
          }
        } else {
          inputTimes.push(point);
        }
      }
    }

    // findFunctionallyEquivalentEventID takes an event from timeline2 and
    // returns the ID of its functional equivalent in timeline1, or -1 if no
    // functional equivalent exists.
    //
    // An event e2 from a replay run is functionally equivalent to an event e1 from
    // the original run iff their fingerprints are the same, and:
    //  - let p2 denote the predecessor of e2
    //  - let s2 denote the successor of e2
    //  - let p1 denote p2's functional equivalent from the original run
    //  - let s1 denote s2's functional equivalent from the original run
    // then e1 must occur between p1 and s1.
    //
    // In other words, the two events should be in the same relative position in the
    // log. In practice we keep track of relative position by always starting
    // from startPos and walking through the trace left to right.
    function findFunctionallyEquivalentEventID(e, startPos){
      for (i_old = startPos; i_old < data_timeline[1].length-1; i_old++) {
        var str_old = data_timeline[1][i_old];
        var e_old = jQuery.parseJSON(str_old);

        // using JSON.stringify() to compute .equals() for objects/arrays in fingerprint
        if (e_old["class"] === e["class"] &&
            JSON.stringify(e_old["fingerprint"]) === JSON.stringify(e["fingerprint"])) {
          return i_old;
        }
      }
      return -1;
    }

  </script>
  <script type="text/javascript">
    var tooltip = {};
    var nullData = [
      {times: []}
    ];
    var width = 4000;
    var charts = [];
    var svgs = [];

    // When an auxiliary chart is loaded, compute an offset in milliseconds from
    // the primary chart. Offsets should be subtracted (positive offsets mean
    // that the secondary chart came after the primary chart)
    // Precondition: primary chart must be loaded
    computeOffset = function(auxiliaryData) {
      // units are milliseconds
      var primaryBegin = chart1.beginning();
      var internalTimes = auxiliaryData[0]["times"];
      if (internalTimes.length < 0) return 0;
      var secondaryBegin = internalTimes[0]["starting_time"];
      var offset = secondaryBegin - primaryBegin;
      return offset;
    }

    applyOffset = function(data) {
      var offsetMillis = computeOffset(data);
      // Apply to both internal and input events
      for (i = 0; i < 2; i++) {
        var points = data[i]["times"];
        for (j = 0; j < points.length; j++) {
          points[j]["starting_time"] -= offsetMillis;
          points[j]["ending_time"] -= offsetMillis;
        }
      }
      return data;
    }

    // Mouseover callback
    showDetails = function(d, i) {
      var content;
      content = '<p class="main">' + d.label + '</span></p>';
      content += '<hr class="tooltip-hr">';
      content += '<p class="main">' + d.class + '</span></p>';
      content += '<p class="main">Time (ms): ' + d.starting_time + '</span></p>';
      tooltip.showTooltip(content, d3.event);
      // TODO(cs): only show functional equivalence lines when the user mouses
      // over a dot (triggered in this handler)
    };

    // Mouseout callback
    hideDetails = function(d, i) {
      tooltip.hideTooltip();
    };

    function timelineCircle(svg, chart, data) {
      svg.datum(data).call(chart);
    }

    function appendToDOM(chartElement, fileElement1, fileElement2) {
      // the order in which elements are currently displayed
      appendElementToDOM("file upload", fileElement1); 
      appendElementToDOM("file upload", fileElement2); 
      appendElementToDOM("chart", chartElement);
    }

    // appendElementToDOM currently only supports two types of elements: 
    // file uploads and charts
    function appendElementToDOM(type, element){
      if (type === "file upload"){ 
        var p = document.createElement('p');
        var input = document.createElement('input');
        input.setAttribute('type', 'file');
        input.setAttribute('id', element);
        p.appendChild(input);
        document.body.appendChild(p);
      } else if (type === "chart"){
        var div = document.createElement('div');
        div.setAttribute('id', element);
        document.body.appendChild(div);
      } 
    }

    function appendChart(data) {
      var index = charts.length;
      var chartElement = "timeline" + index;
      var fileElement1 = "fileinput" + index;
      var fileElement2 = "fileinput" + (index+1);
      appendToDOM(chartElement, fileElement1, fileElement2);
      
      charts.push(d3.timeline()
        .stack()
        .tickFormat(
          {format: d3.time.format("%M:%S:%L"),
          tickTime: d3.time.seconds,
          tickNumber: 5,
          tickSize: 30})
        .rotateTicks(45)
        .display("circle") // toggle between rectangles and circles
        .mouseover(showDetails)
        .mouseout(hideDetails));
      svgs.push(d3.select("#" + chartElement).insert("svg").attr("width", width));
      timelineCircle(svgs[index], charts[index], data);
      initFileUpload(fileElement1, svgs[index], charts[index], true);
      initFileUpload(fileElement2, svgs[index], charts[index], true);
    }

    window.onload = function() {
      tooltip = Tooltip("vis-tooltip", 230);
      appendChart(nullData);
    }
  </script>
</head>
<body>
</body>
</html>
