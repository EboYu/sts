<!doctype html>
<html>
<head>
  <link rel="stylesheet" href="./d3-timeline/css/style.css">
  <!--<script src="http://code.jquery.com/jquery-latest.min.js"></script>-->
  <script src="./d3-timeline/lib/jquery-1.7.2.min.js"></script>
  <script src="./d3-timeline/lib/d3.v3.min.js"></script>
  <script src="./d3-timeline/src/d3-timeline.js"></script>
  <script src="./d3-timeline/lib/Tooltip.js"></script>
  <script type="text/javascript">
    // TODO(cs): add legend
    var primaryChartLoaded = false;
    var invariantViolations = {"InvariantViolation":true};
    var internalEvents = {"ControlMessageReceive":true,
                          "ControlMessageSend":true,
                          "ConnectToControllers":true,
                          "ControllerStateChange":true,
                          "DeterministicValue":true,
                          "DataplanePermit":true};

    var data_timeline = {1:[], 2:[]}; 
    var timeline_num = 0; // {1 or 2}

    function formatData(data) {
      timeline_num++;

      internal_times = {1:[], 2:[]};
      timed_out_times = {1:[], 2:[]};
      input_times = {1:[], 2:[]};
      // TODO(cs): assign the color red to violation_times
      violation_times = {1:[], 2:[]};
      new_event_times = {1:[], 2:[]};

      data_timeline[timeline_num] = data.split("\n"); 
      
      if (timeline_num == 2){ // process after data for both timelines are entered

        processTimeline(1, internal_times[1], timed_out_times[1], input_times[1], violation_times[1], new_event_times[1]); 
        
        processTimeline(2, internal_times[2], timed_out_times[2], input_times[2], violation_times[2], new_event_times[2]);      
      }

      return [{"label": "internal", "times": internal_times[1]},
              {"label": "input", "times": input_times[1]},
              {"label": "timed_out", "times": timed_out_times[1]},
              {"label": "new_internal", "times": new_event_times[1]},
              {"label": "violation", "times": violation_times[1]},
              {"label": "", "times": []},
              {"label": "internal", "times": internal_times[2]},
              {"label": "input", "times": input_times[2]},
              {"label": "timed_out", "times": timed_out_times[2]},
              {"label": "new_internal", "times": new_event_times[2]},
              {"label": "violation", "times": violation_times[2]}];
    }

    function initFileUpload(elementId, svg, chart, primaryChart) {
      var upload = document.getElementById(elementId);

      if (typeof window.FileReader === 'undefined') {
        alert("File API Not Supported");
      }

      upload.onchange = function (e) {
        e.preventDefault();

        var file = upload.files[0],
            reader = new FileReader();

        reader.onload = function (event) {
          var data = formatData(event.target.result);

          if (primaryChart) {
            primaryChartLoaded = true;
          }
          if (!primaryChart && primaryChartLoaded) {
            data = applyOffset(data);
          }

          timelineCircle(svg, chart, data);
        };
        reader.readAsText(file);

        return false;
      };
    }

    function processTimeline(timelineNum, internalTimes, timedOutTimes, inputTimes, violationTimes, newEventTimes){

      var data = data_timeline[timelineNum]; 
      var start_position = 0; 

      for (i = 0; i < data.length-1; i++) {
        var str = data[i];
        var e = jQuery.parseJSON(str);
        var epochMillis = (e["time"][0] * 1000) + (e["time"][1] / 1000);
        var e_id; 

        if (timelineNum == 1) { 
          // arbitrary id that is simply its position in the event list of timeline1
          e_id = i; 
        } else { 
          // id that corresponds to its functionally equivalent event in timeline1
          e_id = findFunctionallyEquivalentEventID(e, start_position);
          
          // update the starting position for the next event (to keep relative ordering correct) 
          if (e_id != -1){ 
            start_position = e_id+1; 
          } 
        }

        var point = {"starting_time": epochMillis,
                     "ending_time": epochMillis,
                     "label": e["label"],
                     "class": e["class"],
                     "fe_id": e_id};

        // Demultiplex by element["class"] for internal vs. input
        var eventClass = e["class"];
        if (eventClass === "InvariantViolation") {
          violationTimes.push(point);
        } else if (eventClass in internalEvents)  {
          if ("timed_out" in e && e["timed_out"]) {
            timedOutTimes.push(point);
          } else if ("new_internal_event" in e && e["new_internal_event"]) {
            newEventTimes.push(point);
          } else {
            internalTimes.push(point);
          }
        } else {
          inputTimes.push(point);
        }
      }

    }

    // An event e2 from a replay run is functionally equivalent to an event e1 from 
    // the original run iff their fingerprints are the same, and: let p2 denote the 
    // predecessor of e2 let s2 denote the successor of e2 let p1 denote p2's 
    // functional equivalent from the original run let s1 denote s2's functional 
    // equivalent from the original run then e1 must occur between p1 and s1.
    // In other words, the two events should be in the same relative position in the 
    // log. If you draw the lines starting from the front of the log and working your 
    // way to the back, you shouldn't need to worry about the technicality of that.

    function findFunctionallyEquivalentEventID(e, startPos){ 
      for (i_old = startPos; i_old < data_timeline[1].length-1; i_old++) {
        var str_old = data_timeline[1][i_old];
        var e_old = jQuery.parseJSON(str_old);

        // using JSON.stringify() to compute .equals() for objects/arrays in fingerprint
        if ( e_old["class"] === e["class"] 
          && JSON.stringify(e_old["fingerprint"]) === JSON.stringify(e["fingerprint"]) ){
            return i_old;
        }
      }
      return -1;
    }

  </script>
  <script type="text/javascript">
    var tooltip = {};
    var nullData = [
      {times: []}
    ];
    var width = 4000;
    var charts = [];
    var svgs = [];

    // When an auxiliary chart is loaded, compute an offset in milliseconds from
    // the primary chart. Offsets should be subtracted (positive offsets mean
    // that the secondary chart came after the primary chart)
    // Precondition: primary chart must be loaded
    computeOffset = function(auxiliaryData) {
      // units are milliseconds
      var primaryBegin = chart1.beginning();
      var internalTimes = auxiliaryData[0]["times"];
      if (internalTimes.length < 0) return 0;
      var secondaryBegin = internalTimes[0]["starting_time"];
      var offset = secondaryBegin - primaryBegin;
      return offset;
    }

    applyOffset = function(data) {
      var offsetMillis = computeOffset(data);
      // Apply to both internal and input events
      for (i = 0; i < 2; i++) {
        var points = data[i]["times"];
        for (j = 0; j < points.length; j++) {
          points[j]["starting_time"] -= offsetMillis;
          points[j]["ending_time"] -= offsetMillis;
        }
      }
      return data;
    }

    // Mouseover callback
    showDetails = function(d, i) {
      var content;
      content = '<p class="main">' + d.label + '</span></p>';
      content += '<hr class="tooltip-hr">';
      content += '<p class="main">' + d.class + '</span></p>';
      content += '<p class="main">Time (ms): ' + d.starting_time + '</span></p>';
      tooltip.showTooltip(content, d3.event);
    };

    // Mouseout callback
    hideDetails = function(d, i) {
      tooltip.hideTooltip();
    };

    function timelineCircle(svg, chart, data) {
      svg.datum(data).call(chart);
    }

    function appendToDOM(chartElement, fileElement1, fileElement2) {
      var p = document.createElement('p');
      var input = document.createElement('input');
      input.setAttribute('type', 'file');
      input.setAttribute('id', fileElement1);
      p.appendChild(input);
      document.body.appendChild(p);
      var p = document.createElement('p');
      var input = document.createElement('input');
      input.setAttribute('type', 'file');
      input.setAttribute('id', fileElement2);
      p.appendChild(input);
      document.body.appendChild(p);
      var div = document.createElement('div');
      div.setAttribute('id', chartElement);
      document.body.appendChild(div);
    }

    function appendChart(data) {
      var index = charts.length;
      var chartElement = "timeline" + index;
      var fileElement1 = "fileinput" + index;
      var fileElement2 = "fileinput" + (index+1);
      appendToDOM(chartElement, fileElement1, fileElement2);

      charts.push(d3.timeline()
        .stack()
        .tickFormat(
          {format: d3.time.format("%M:%S:%L"),
          tickTime: d3.time.seconds,
          tickNumber: 5,
          tickSize: 30})
        .rotateTicks(45)
        .display("circle") // toggle between rectangles and circles
        .mouseover(showDetails)
        .mouseout(hideDetails));
      svgs.push(d3.select("#" + chartElement).insert("svg").attr("width", width));
      timelineCircle(svgs[index], charts[index], data);
      initFileUpload(fileElement1, svgs[index], charts[index], true);
      initFileUpload(fileElement2, svgs[index], charts[index], true);
    }

    window.onload = function() {
      tooltip = Tooltip("vis-tooltip", 230);
      appendChart(nullData);
    }
  </script>
</head>
<body>
</body>
</html>