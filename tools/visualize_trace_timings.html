<!doctype html>
<html>
<head>
  <link rel="stylesheet" href="./d3-timeline/css/style.css">
  <!--<script src="http://code.jquery.com/jquery-latest.min.js"></script>-->
  <script src="./d3-timeline/lib/jquery-1.7.2.min.js"></script>
  <script src="./d3-timeline/lib/d3.v3.min.js"></script>
  <script src="./d3-timeline/src/d3-timeline.js"></script>
  <script src="./d3-timeline/lib/Tooltip.js"></script>
  <script type="text/javascript">
    // TODO(cs): add legend
    var primaryChartLoaded = false;
    var invariantViolations = {"InvariantViolation":true};
    var internalEvents = {"ControlMessageReceive":true,
                          "ControlMessageSend":true,
                          "ConnectToControllers":true,
                          "ControllerStateChange":true,
                          "DeterministicValue":true,
                          "DataplanePermit":true};

    function formatData(data) {
      internal_times = [];
      timed_out_times = [];
      input_times = [];
      // TODO(cs): assign the color red to violation_times
      violation_times = [];
      new_event_times = [];
      // Split by \n
      var split = data.split("\n");
      for (i = 0; i < split.length-1; i++) {
        var str = split[i];
        var e = jQuery.parseJSON(str);
        var epochMillis = (e["time"][0] * 1000) + (e["time"][1] / 1000);
        var point = {"starting_time": epochMillis,
                     "ending_time": epochMillis,
                     "label": e["label"],
                     "class": e["class"]};
        // Demultiplex by element["class"] for internal vs. input
        var eventClass = e["class"];
        if (eventClass === "InvariantViolation") {
          violation_times.push(point);
        } else if (eventClass in internalEvents)  {
          if ("timed_out" in e && e["timed_out"]) {
            timed_out_times.push(point);
          } else if ("new_internal_event" in e && e["new_internal_event"]) {
            new_event_times.push(point);
          } else {
            internal_times.push(point);
          }
        } else {
          input_times.push(point);
        }
      }

      return [{"label": "internal", "times": internal_times},
              {"label": "input", "times": input_times},
              {"label": "timed_out", "times": timed_out_times},
              {"label": "new_internal", "times": new_event_times},
              {"label": "violation", "times": violation_times}];
    }
    function initFileUpload(elementId, svg, chart, primaryChart) {
      var upload = document.getElementById(elementId);

      if (typeof window.FileReader === 'undefined') {
        alert("File API Not Supported");
      }

      upload.onchange = function (e) {
        e.preventDefault();

        var file = upload.files[0],
            reader = new FileReader();

        reader.onload = function (event) {
          var data = formatData(event.target.result);

          if (primaryChart) {
            primaryChartLoaded = true;
          }
          if (!primaryChart && primaryChartLoaded) {
            data = applyOffset(data);
          }

          timelineCircle(svg, chart, data);
          // Add another chart element for the user to compare any number of
          // charts
          appendChart(nullData);
        };
        reader.readAsText(file);

        return false;
      };
    }
  </script>
  <script type="text/javascript">
    var tooltip = {};
    var nullData = [
      {times: []}
    ];
    var width = 2000;
    var charts = [];
    var svgs = [];

    // When an auxiliary chart is loaded, compute an offset in milliseconds from
    // the primary chart. Offsets should be subtracted (positive offsets mean
    // that the secondary chart came after the primary chart)
    // Precondition: primary chart must be loaded
    computeOffset = function(auxiliaryData) {
      // units are milliseconds
      var primaryBegin = chart1.beginning();
      var internalTimes = auxiliaryData[0]["times"];
      if (internalTimes.length < 0) return 0;
      var secondaryBegin = internalTimes[0]["starting_time"];
      var offset = secondaryBegin - primaryBegin;
      return offset;
    }

    applyOffset = function(data) {
      var offsetMillis = computeOffset(data);
      // Apply to both internal and input events
      for (i = 0; i < 2; i++) {
        var points = data[i]["times"];
        for (j = 0; j < points.length; j++) {
          points[j]["starting_time"] -= offsetMillis;
          points[j]["ending_time"] -= offsetMillis;
        }
      }

      return data;
    }

    // Mouseover callback
    showDetails = function(d, i) {
      var content;
      content = '<p class="main">' + d.label + '</span></p>';
      content += '<hr class="tooltip-hr">';
      content += '<p class="main">' + d.class + '</span></p>';
      content += '<p class="main">Time (ms): ' + d.starting_time + '</span></p>';
      tooltip.showTooltip(content, d3.event);
    };

    // Mouseout callback
    hideDetails = function(d, i) {
      tooltip.hideTooltip();
    };

    function timelineCircle(svg, chart, data) {
      svg.datum(data).call(chart);
    }

    function appendToDOM(chartElement, fileElement) {
      document.body.innerHTML += "<p><input type=file id=" + fileElement + "></p>";
      document.body.innerHTML += "<div id=" + chartElement + "></div>";
    }

    function appendChart(data) {
      var index = charts.length;
      var chartElement = "timeline" + index;
      var fileElement = "fileinput" + index;
      appendToDOM(chartElement, fileElement);

      charts.push(d3.timeline()
        .tickFormat(
          {format: d3.time.format("%M:%S:%L"),
          tickTime: d3.time.seconds,
          tickNumber: 10,
          tickSize: 30})
        .rotateTicks(45)
        .display("circle") // toggle between rectangles and circles
        .mouseover(showDetails)
        .mouseout(hideDetails));
      svgs.push(d3.select("#" + chartElement).insert("svg").attr("width", width));
      timelineCircle(svgs[index], charts[index], data);
      initFileUpload(fileElement, svgs[index], charts[index], true);
    }

    window.onload = function() {
      tooltip = Tooltip("vis-tooltip", 230);
      appendChart(nullData);
    }
  </script>
</head>
<body>
</body>
</html>
