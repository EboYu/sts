<!doctype html>
<!--
This is a webpage for visualizing event traces.
It's especially useful for debugging non-deterministic replays by comparing the
timings of different replay runs.

A common workflow:
  - Run ./simulator.py -c experiments/experiment_name/mcs_config.py
  - Discover that the final MCS does not trigger the bug.
  - Open visualize_trace_timings.html in a web browser.
  - Load the original trace, experiments/experiment_name/events.trace,
    as the first timeline.
  - Load the MCS trace, experiments/experiment_name_mcs/mcs.trace,
    as the second timeline.
  - Hover over events to see functional equivalence across the traces.
  - Load intermediate replay trace timelines if needed. Intermediate replay
    traces from delta debugging runs can be found in
    experiments/experiment_name_mcs/interreplay_*
-->
<html>
<head>
  <link rel="stylesheet" href="./d3-timeline/css/style.css">
  <!--<script src="http://code.jquery.com/jquery-latest.min.js"></script>-->
  <script src="./d3-timeline/lib/jquery-1.7.2.min.js"></script>
  <script src="./d3-timeline/lib/d3.v3.min.js"></script>
  <script src="./d3-timeline/src/d3-timeline.js"></script>
  <script src="./d3-timeline/lib/Tooltip.js"></script>
  <script src="./visualize_trace_timings_lib.js"></script>
  <script type="text/javascript">

    var primaryChartLoaded = false;
    var invariantViolations = {"InvariantViolation":true};
    var internalEvents = {"ControlMessageReceive":true,
                          "ControlMessageSend":true,
                          "ConnectToControllers":true,
                          "ControllerStateChange":true,
                          "DeterministicValue":true,
                          "DataplanePermit":true};

    // determines the number of toggle buttons at the top
    const numTimelines = 4;

    // The key is the timeline index, and the value
    var data_timeline = {};
    // timeline_num is a counter tracking what chart we are currently loading:
    // the first time we load this is set to 1, and incremented for
    // every subsequent load.
    var timeline_num = 0;
    // stores the results for formatData
    var result_timeline = {};
    // stores of the fe_id for all events
    var All_Events_Hash = {};
    // keeps track of the next available fe_id to be assigned to a new event
    var new_event_count = 0;

    function formatData(data) {
      timeline_num++;

      prepData(data, timeline_num);

      processTimelineData(timeline_num, result_timeline);

      return formatDataResult(result_timeline);
    }

    function prepData(data, timeline_num){
      // Store arrays of raw json strings until both charts are loaded.
      data_timeline[timeline_num] = data.split("\n");
      All_Events_Hash[timeline_num] = [];
      result_timeline[timeline_num] = { "internal": [], "input": [], "timed out": [], "new internal": [], "violation": []};
    }

    function formatDataResult(result_timeline){
      var result = [];
      for (var timeline_id in result_timeline){
        for (var times in result_timeline[timeline_id]){
          var s = {};
          s["label"] = "" + times;
          s["times"] = result_timeline[timeline_id][times];
          result.push(s);
        }
        var s = {};
        s["label"] = "";
        s["times"] = [];
        result.push(s);
      }
      return result;
    }

    function processTimelineData(timelineNum, result_timeline){

      var data = data_timeline[timelineNum];
      var start_position = 0;

      for (i = 0; i < data.length-1; i++) {
        var str = data[i];
        var e = jQuery.parseJSON(str);
        var epochMillis = (e["time"][0] * 1000) + (e["time"][1] / 1000);
        var e_id;

        if (timelineNum == 1) {
          // arbitrary id that is simply its position in the event list of timeline1
          e_id = new_event_count;
          new_event_count++;
        } else {
          // id that corresponds to its functionally equivalent event in timeline1
          e_id = findFunctionallyEquivalentEventID(e, start_position, timeline_num);

          // update the starting position for the next event (to keep relative ordering correct)
          if (e_id != -1) {
            start_position = e_id+1;
          } else {
            // did not find a functionally equivalent event, therefore assign a new fe_id
            e_id = new_event_count;
            new_event_count++;
          }
        }

        var point = {"starting_time": epochMillis,
                     "ending_time": epochMillis,
                     "label": e["label"],
                     "class": e["class"],
                     "fe_id": e_id};

        All_Events_Hash[timeline_num].push(e_id);

        // Demultiplex by element["class"] for internal vs. input
        var eventClass = e["class"];
        if (eventClass === "InvariantViolation") {
          result_timeline[timeline_num]["violation"].push(point);
        } else if (eventClass in internalEvents)  {
          if ("timed_out" in e && e["timed_out"]) {
            result_timeline[timeline_num]["timed out"].push(point);
          } else if ("new_internal_event" in e && e["new_internal_event"]) {
            result_timeline[timeline_num]["new internal"].push(point);
          } else {
            result_timeline[timeline_num]["internal"].push(point);
          }
        } else {
          result_timeline[timeline_num]["input"].push(point);
        }
      }
    }

    // findFunctionallyEquivalentEventID takes an event from timeline2 and
    // returns the ID of its functional equivalent in timeline1, or -1 if no
    // functional equivalent exists.
    //
    // An event e2 from a replay run is functionally equivalent to an event e1 from
    // the original run iff their fingerprints are the same, and:
    //  - let p2 denote the predecessor of e2
    //  - let s2 denote the successor of e2
    //  - let p1 denote p2's functional equivalent from the original run
    //  - let s1 denote s2's functional equivalent from the original run
    // then e1 must occur between p1 and s1.
    //
    // In other words, the two events should be in the same relative position in the
    // log. In practice we keep track of relative position by looking for the fe_id
    // of the event right before, and then searching for an fe_id that is the largest
    // smaller fe_id than that.

    function findFunctionallyEquivalentEventID(e, startPos, timeline_num){
      for (t_num = 1; t_num < timeline_num; t_num++){
        for (i_old = startPos; i_old < data_timeline[t_num].length-1; i_old++) {
          var str_old = data_timeline[t_num][i_old];
          var e_old = jQuery.parseJSON(str_old);

          // using JSON.stringify() to compute .equals() for objects/arrays in fingerprint
          if (JSON.stringify(e_old["fingerprint"]) === JSON.stringify(e["fingerprint"])) {
            return All_Events_Hash[t_num][i_old];
          }
        }
      }

      return -1;
    }

  </script>
  <script type="text/javascript">

    // Mouseover callback
    showDetails = function(d, i, datum, IDs, g) {
      var content;
      content = '<p class="main">' + d.label + '</span></p>';
      content += '<hr class="tooltip-hr">';
      content += '<p class="main">' + d.class + '</span></p>';
      content += '<p class="main">Time (ms): ' + d.starting_time + '</span></p>';
      tooltip.showTooltip(content, d3.event);

        // show functional equivalence lines when the user mouses over the event
        if (IDs[d.fe_id].length >= 4){
          for ( i = 0; i < IDs[d.fe_id].length-2; i+=2) {
            g.append('line')
              .attr("x1", IDs[d.fe_id][i])
              .attr("y1", IDs[d.fe_id][i+1])
              .attr("x2", IDs[d.fe_id][i+2])
              .attr("y2", IDs[d.fe_id][i+3])
              .style("stroke","rgb(255,0,0)");
          }
        }

    };

    // Mouseout callback
    hideDetails = function(d, i, datum, IDs, g) {
      tooltip.hideTooltip();

        // remove functional equivalence lines after the user mouses over the event
        lines = g.selectAll("line");
        lastElement = lines[0].length-1;
        for ( i = 0; i < IDs[d.fe_id].length/2; i++){
          lines[0][lastElement-i].remove();
        }

    };


    function appendChart(data) {
      var index = charts.length;
      var chartElement = "timeline" + index;
      var fileElements = [];
      for ( i = 0; i < numTimelines; i++){
        var file = "fileinput" + (index + i);
        fileElements[i]=file;
      }
      appendToDOM(fileElements, chartElement, "1d");

      charts.push(d3.timeline("1d")
        .stack()
        .tickFormat(
          {format: d3.time.format("%M:%S:%L"),
          tickTime: d3.time.seconds,
          tickNumber: 5,
          tickSize: 30})
        .rotateTicks(45)
        .display("circle") // toggle between rectangles and circles
        .mouseover(showDetails)
        .mouseout(hideDetails));
      svgs.push(d3.select("#" + chartElement).insert("svg").attr("width", width));

      timelineCircle(svgs[index], charts[index], data);
      for (i = 0; i < fileElements.length; i++){
        initFileUpload(fileElements[i], svgs[index], charts[index], true, "1d");
      }
    }

  </script>
</head>
<body>
</body>
</html>
